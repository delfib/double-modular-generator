-- =========================================================
--  R Protocol Models: Nominal and Extended Versions
-- =========================================================
-- This NuSMV model implements the R protocol with a client sending
-- requests to one or more servers through a fixed-size queue. The
-- nominal version captures the basic, fault-free behavior of the
-- client and server, while the extended version introduces server
-- failures, allowing each server to nondeterministically fail during
-- execution. The synchronization module allows comparison of client
-- behavior and message consumption between the nominal and extended
-- models, enabling verification of correctness under possible server
-- faults.
-- =========================================================


-- =========================================================
--  R Protocol: Nominal version
-- =========================================================

MODULE Client(ch_head_server, Q_SIZE)
VAR
    client_state : {sending, sent};     -- State of the client: sending = 0, sent = 1
    ch_tail_client : 0..3;       -- Tail pointer of the request queue
    full_channel : boolean; 

ASSIGN
    init(client_state) := sending;
    init(ch_tail_client) := 0;
    init(full_channel) := FALSE;

    next(full_channel) := ((ch_tail_client + 1) mod Q_SIZE) = ch_head_server;    
    next(client_state) :=
        case
            client_state = sending & full_channel : sending;
            client_state = sending & !full_channel : sent;
            client_state = sent & !full_channel : sending;
            client_state = sent & full_channel : sent;                 
        esac;

    -- the tail pointer is only updated once a message is sent
    next(ch_tail_client) :=
        case
            -- ch_tail_client = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            client_state = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            TRUE : ch_tail_client;
        esac;
FAIRNESS
    running


MODULE Server(ch_tail_client, Q_SIZE)
VAR
    server_state : {receiving, received};    -- State of the server: receiving = 0, received = 1
    ch_head_server : 0..3;                   -- Head pointer of the request queue
    empty_channel : boolean; 

ASSIGN
    init(server_state) := receiving;
    init(ch_head_server) := 0;
    init(empty_channel) := TRUE;

    next(empty_channel) := (ch_tail_client = ch_head_server);
    next(server_state) :=
        case
            server_state = receiving & empty_channel : receiving;
            server_state = receiving & !empty_channel : received;
            server_state = received & !empty_channel : receiving;
            server_state = received & empty_channel : received;   
            TRUE : server_state; 
        esac;

    next(ch_head_server) :=
        case
            server_state = receiving & !empty_channel : (ch_head_server + 1) mod Q_SIZE;
            TRUE : ch_head_server;
        esac;
FAIRNESS
    running


-- =========================================================
--  Nominal model wrapper 
-- =========================================================
MODULE NominalR()
DEFINE
    Q_SIZE := 4;
    NOMINAL_CONSUMED := server.server_state = received;
VAR
    client : process Client(server.ch_head_server, Q_SIZE);
    server : process Server(client.ch_tail_client, Q_SIZE);



-- =========================================================
--  Extended R Protocol (with faults)
-- =========================================================
MODULE ServerExtended(ch_tail_client, Q_SIZE, head_pointer)
VAR
    server_state : {receiving, received, failed};  
    empty_channel : boolean; 

ASSIGN
    init(server_state) := receiving;
    init(empty_channel) := TRUE;

    next(empty_channel) := (ch_tail_client = head_pointer);
    next(server_state) :=
        case
            server_state = receiving & empty_channel : {receiving, failed};
            server_state = receiving & !empty_channel : {received, failed};
            server_state = received & !empty_channel : {receiving, failed};
            server_state = received & empty_channel : {received, failed};     
            server_state = failed : failed;
        esac;

    next(head_pointer) :=
        case
            server_state = receiving & !empty_channel : (head_pointer + 1) mod Q_SIZE;
            TRUE : head_pointer;
        esac;
FAIRNESS
    running



-- =========================================================
--  Extended model wrapper 
-- =========================================================
MODULE ExtendedR()
DEFINE
    Q_SIZE := 4;

    -- CONSUMED is TRUE if either server1 or server2 consumed a message
    CONSUMED := server1.server_state = received | server2.server_state = received;
VAR
    head_pointer : 0..3;
    client  : process Client(head_pointer, Q_SIZE);
    server1 : process ServerExtended(client.ch_tail_client, Q_SIZE, head_pointer);
    server2 : process ServerExtended(client.ch_tail_client, Q_SIZE, head_pointer);

ASSIGN
    init(head_pointer) := 0;



-- =========================================================
--  Synchronization Module
-- =========================================================
MODULE Sync()
VAR
    nominal  : NominalR();
    extended : ExtendedR();


-- Whenever nominal server consumes, eventually an extended server consumes
SPEC AG (nominal.server.server_state = received -> AF (extended.server1.server_state = received | extended.server2.server_state = received))
--SPEC AG (nominal.NOMINAL_CONSUMED -> AF extended.CONSUMED)



-- =========================================================
--  Main Module (entry point)
-- =========================================================
MODULE main
VAR
    sync : Sync();