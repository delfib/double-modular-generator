-- =========================================================
--  Extended R Protocol with Independent Failure Counters
-- =========================================================
-- This model is an extension of the nominal R Protocol to include
-- fault-tolerant behavior using independent counters for each server.
--
-- Each extended server has its own counter, initialized to a fixed
-- value N. On each execution step of the server, the counter
-- decrements by 1. When the counter reaches zero, the corresponding
-- server transitions to the 'failed' state.
-- =========================================================


-- =========================================================
--  R Protocol: Nominal version
-- =========================================================

MODULE Client(ch_head_server, Q_SIZE)
VAR
    client_state : {sending, sent};     -- State of the client: sending = 0, sent = 1
    ch_tail_client : 0..3;       -- Tail pointer of the request queue
    full_channel : boolean; 

ASSIGN
    init(client_state) := sending;
    init(ch_tail_client) := 0;
    init(full_channel) := FALSE;

    next(full_channel) := ((ch_tail_client + 1) mod Q_SIZE) = ch_head_server;    
    next(client_state) :=
        case
            client_state = sending & full_channel : sending;
            client_state = sending & !full_channel : sent;
            client_state = sent & !full_channel : sending;
            client_state = sent & full_channel : sent;                 
        esac;

    -- the tail pointer is only updated once a message is sent
    next(ch_tail_client) :=
        case
            -- ch_tail_client = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            client_state = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            TRUE : ch_tail_client;
        esac;
FAIRNESS
    running


MODULE Server(ch_tail_client, Q_SIZE)
VAR
    server_state : {receiving, received};    -- State of the server: receiving = 0, received = 1
    ch_head_server : 0..3;                   -- Head pointer of the request queue
    empty_channel : boolean; 

ASSIGN
    init(server_state) := receiving;
    init(ch_head_server) := 0;
    init(empty_channel) := TRUE;

    next(empty_channel) := (ch_tail_client = ch_head_server);
    next(server_state) :=
        case
            server_state = receiving & empty_channel : receiving;
            server_state = receiving & !empty_channel : received;
            server_state = received & !empty_channel : receiving;
            server_state = received & empty_channel : received;   
            TRUE : server_state; 
        esac;

    next(ch_head_server) :=
        case
            server_state = receiving & !empty_channel : (ch_head_server + 1) mod Q_SIZE;
            TRUE : ch_head_server;
        esac;
FAIRNESS
    running


-- =========================================================
--  Nominal model wrapper 
-- =========================================================
MODULE NominalR()
DEFINE
    Q_SIZE := 4;
VAR
    client : process Client(server.ch_head_server, Q_SIZE);
    server : process Server(client.ch_tail_client, Q_SIZE);



-- =========================================================
--  Extended R Protocol (with faults)
-- =========================================================
MODULE ServerExtended(ch_tail_client, Q_SIZE, head_pointer, N)
VAR
    server_state : {receiving, received, failed};  
    empty_channel : boolean; 
    counter : 0.. N;

ASSIGN
    init(server_state) := receiving;
    init(empty_channel) := TRUE;
    init(counter) := N;

    next(empty_channel) := (ch_tail_client = head_pointer);
    next(counter) :=
        case
            server_state != failed & counter > 0 : counter - 1;
            TRUE : counter;
        esac;

    next(server_state) :=
        case
            counter = 0 : failed;  
            server_state = receiving & empty_channel : receiving;
            server_state = receiving & !empty_channel : received;
            server_state = received & !empty_channel : receiving;
            server_state = received & empty_channel : received;     
            server_state = failed : failed;
        esac;

    next(head_pointer) :=
        case
            server_state = receiving & !empty_channel : (head_pointer + 1) mod Q_SIZE;
            TRUE : head_pointer;
        esac;

FAIRNESS
    running



-- =========================================================
--  Extended model wrapper 
-- =========================================================
MODULE ExtendedRCounter()
DEFINE
    Q_SIZE := 4;
VAR
    head_pointer : 0..3;
    client  : process Client(head_pointer, Q_SIZE);
    server1 : process ServerExtended(client.ch_tail_client, Q_SIZE, head_pointer, 5);
    server2 : process ServerExtended(client.ch_tail_client, Q_SIZE, head_pointer, 7);



-- =========================================================
--  Synchronization Module
-- =========================================================
MODULE Sync()
VAR
    nominal  : NominalR();
    extended : ExtendedRCounter();



-- Whenever nominal server consumes, eventually an extended server consumes
SPEC AG (nominal.server.server_state = received -> AF (extended.server1.server_state = received | extended.server2.server_state = received))




-- =========================================================
--  Main Module (entry point)
-- =========================================================
MODULE main
VAR
    sync : Sync();