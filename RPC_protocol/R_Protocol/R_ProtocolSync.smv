-- =========================================================
-- Nominal Queue module
-- =========================================================
MODULE QueueNominal(Q_SIZE, client_toggle, server_toggle)
VAR
    head : 0..3;
    tail : 0..3;
    last_client_toggle : boolean;  -- last toggle value we saw
    last_server_toggle : boolean;

ASSIGN
    init(head) := 0;
    init(tail) := 0;
    init(last_client_toggle) := FALSE;
    init(last_server_toggle) := FALSE;

    next(tail) := case
        (client_toggle != last_client_toggle) : (tail + 1) mod Q_SIZE;    -- produce if toggle changed (new request detected)
        TRUE : tail;
    esac;

    next(head) := case
        (server_toggle != last_server_toggle) : (head + 1) mod Q_SIZE;
        TRUE : head;
    esac;

    next(last_client_toggle) := case
        (client_toggle != last_client_toggle) : client_toggle;
        TRUE : last_client_toggle;
    esac;

    next(last_server_toggle) := case
        (server_toggle != last_server_toggle) : server_toggle;
        TRUE : last_server_toggle;
    esac;

DEFINE
    full := ((tail + 1) mod Q_SIZE = head);
    empty := (tail = head);

FAIRNESS
    running


-- =========================================================
-- Client module
-- =========================================================
MODULE Client(queue)
VAR
    client_state : {sending, sent};
    request_toggle : boolean;           

ASSIGN
    init(client_state) := sending;
    init(request_toggle) := FALSE;

    next(client_state) :=
        case
            client_state = sending & queue.full : sending;
            client_state = sending & !queue.full : sent;
            client_state = sent & !queue.full & request_toggle = queue.last_client_toggle : sending;
            client_state = sent & queue.full : sent;
            TRUE : client_state;
        esac;
 
    -- Toggle the bit each time we make a new request
    next(request_toggle) := case
        client_state = sending & !queue.full : !request_toggle;                     -- toggle!
        TRUE : request_toggle;                                                      -- keep same value otherwise
    esac;

FAIRNESS
    running


-- =========================================================
-- Nominal Server module
-- =========================================================
MODULE Server(queue)
VAR
    server_state : {receiving, received};
    request_toggle : boolean;  
ASSIGN
    init(server_state) := receiving;
    init(request_toggle) := FALSE;

    next(server_state) :=
        case
            server_state = receiving & queue.empty : receiving;
            server_state = receiving & !queue.empty : received;
            server_state = received & !queue.empty & request_toggle = queue.last_server_toggle: receiving;
            server_state = received & queue.empty : received;
            TRUE : server_state;
        esac;

    next(request_toggle) := case
        server_state = receiving & !queue.empty : !request_toggle;                   
        TRUE : request_toggle;                                                    
    esac;

FAIRNESS
    running


-- =========================================================
-- Nominal wrapper
-- =========================================================
MODULE NominalR()
DEFINE
    Q_SIZE := 4;
VAR
    client : process Client(queue);
    server : process Server(queue);
    queue : process QueueNominal(Q_SIZE, client.request_toggle, server.request_toggle);



-- =========================================================
-- Extended Queue (handles 2 servers)
-- =========================================================
MODULE QueueExtended(Q_SIZE, client_toggle, server1_toggle, server2_toggle)
VAR
    head : 0..3;
    tail : 0..3;
    last_client_toggle : boolean;
    last_server1_toggle : boolean;
    last_server2_toggle : boolean;

ASSIGN
    init(head) := 0;
    init(tail) := 0;
    init(last_client_toggle) := FALSE;
    init(last_server1_toggle) := FALSE;
    init(last_server2_toggle) := FALSE;

    next(tail) := case
        (client_toggle != last_client_toggle) : (tail + 1) mod Q_SIZE;
        TRUE : tail;
    esac;

    next(head) := case
        (server1_toggle != last_server1_toggle) : (head + 1) mod Q_SIZE;
        (server2_toggle != last_server2_toggle) : (head + 1) mod Q_SIZE;
        TRUE : head;
    esac;

    next(last_client_toggle) := case
        (client_toggle != last_client_toggle) : client_toggle;
        TRUE : last_client_toggle;
    esac;

    next(last_server1_toggle) := case
        (server1_toggle != last_server1_toggle) : server1_toggle;
        TRUE : last_server1_toggle;
    esac;

    next(last_server2_toggle) := case
        (server2_toggle != last_server2_toggle) : server2_toggle;
        TRUE : last_server2_toggle;
    esac;

DEFINE
    full := ((tail + 1) mod Q_SIZE = head);
    empty := (tail = head);

FAIRNESS
    running


-- =========================================================
-- Extended Server module 
-- =========================================================
MODULE ServerExtended(queue, N, last_queue_toggle)
VAR
    server_state : {receiving, received, failed};
    request_toggle : boolean;  
    counter : 0..N;
ASSIGN
    init(server_state) := receiving;
    init(request_toggle) := FALSE;
    init(counter) := N;

    next(counter) :=
        case
            server_state != failed & counter > 0 : counter - 1;
            TRUE : counter;
        esac;
        
    next(server_state) :=
        case
            counter = 0 : failed;
            server_state = receiving & queue.empty : receiving;
            server_state = receiving & !queue.empty : received;
            server_state = received & !queue.empty & request_toggle = last_queue_toggle: receiving;
            server_state = received & queue.empty : received;
            server_state = failed : failed;
            TRUE : server_state;
        esac;

    next(request_toggle) := case
        server_state = receiving & !queue.empty : !request_toggle;                   
        TRUE : request_toggle;                                                    
    esac;

FAIRNESS
    running



-- =========================================================
-- Extended model wrapper 
-- =========================================================
MODULE ExtendedR()
DEFINE
    Q_SIZE := 4;
    N1 := 5;  
    N2 := 7;  

VAR
    client : process Client(queue);
    server1 : process ServerExtended(queue, N1, queue.last_server1_toggle);
    server2 : process ServerExtended(queue, N2, queue.last_server2_toggle);
    queue : process QueueExtended(Q_SIZE, 
                                  client.request_toggle, 
                                  server1.request_toggle, 
                                  server2.request_toggle);


-- =========================================================
--  Synchronization Module
-- =========================================================
MODULE Sync()
VAR
    nominal  : NominalR();
    extended : ExtendedR();


-- Whenever nominal server consumes, eventually an extended server consumes
SPEC AG (nominal.server.server_state = received -> AF (extended.server1.server_state = received | extended.server2.server_state = received))

-- =========================================================
--  Main Module (entry point)
-- =========================================================
MODULE main
VAR
    sync : Sync();

