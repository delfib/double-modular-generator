-- =========================================================
-- Queue module
-- =========================================================
MODULE Queue(Q_SIZE, readyToProduce, readyToConsume)
VAR
    head : 0..3;
    tail : 0..3;
    full : boolean;
    empty : boolean;
    produce_used : boolean;  -- track if we already acted on current produce signal
    consume_used : boolean;  -- track if we already acted on current consume signal
    

ASSIGN
    init(head) := 0;
    init(tail) := 0;
    init(full) := FALSE;
    init(empty) := TRUE;
    init(produce_used) := FALSE;
    init(consume_used) := FALSE;

    next(full) := ((tail + 1) mod Q_SIZE = head);
    next(empty) := (tail = head);

    next(tail) := case
        readyToProduce & !produce_used : (tail + 1) mod Q_SIZE;
        TRUE : tail;
    esac;

    next(head) := case
        readyToConsume & !consume_used : (head + 1) mod Q_SIZE;
        TRUE : head;
    esac;

    next(produce_used) := case
        !readyToProduce : FALSE;                -- client changed state, reset
        readyToProduce & !produce_used : TRUE;  -- we just consumed it
        TRUE : produce_used;                    -- keep it consumed
    esac;

    next(consume_used) := case
        !readyToConsume : FALSE;
        readyToConsume & !consume_used : TRUE;
        TRUE : consume_used;
    esac;

FAIRNESS
    running


-- =========================================================
-- Client module
-- =========================================================
MODULE Client(queue)
VAR
    client_state : {sending, sent};
    readyToProduce : boolean;
    prev_tail : 0..3;  -- track when queue actually moves

ASSIGN
    init(client_state) := sending;
    init(readyToProduce) := FALSE;
    init(prev_tail) := 0;

    next(prev_tail) := queue.tail;

    next(client_state) :=
        case
            client_state = sending & queue.full : sending;
            client_state = sending & !queue.full : sent;
            client_state = sent & !queue.full & prev_tail != queue.tail : sending;
            client_state = sent & queue.full : sent;
            TRUE : client_state;
        esac;
 
    next(readyToProduce) := case
        client_state = sending & !queue.full : TRUE;   
        client_state = sent & prev_tail = queue.tail & !queue.full : TRUE;  -- keep TRUE while waiting for queue to get updated
        TRUE : FALSE;  
    esac;

FAIRNESS
    running


-- =========================================================
-- Server module (nominal)
-- =========================================================
MODULE Server(queue)
VAR
    server_state : {receiving, received};
    readyToConsume : boolean;
    prev_head : 0..3;
ASSIGN
    init(server_state) := receiving;
    init(readyToConsume) := FALSE;
    init(prev_head) := 0;

    next(prev_head) := queue.head;

    next(server_state) :=
        case
            server_state = receiving & queue.empty : receiving;
            server_state = receiving & !queue.empty : received;
            server_state = received & !queue.empty & prev_head != queue.head: receiving;
            server_state = received & queue.empty : received;
            TRUE : server_state;
        esac;

    next(readyToConsume) := case
        server_state = receiving & !queue.empty : TRUE;   
        server_state = received & prev_head = queue.head & !queue.empty: TRUE;  -- keep TRUE while waiting for queue to get updated
        TRUE : FALSE;  
    esac;

FAIRNESS
    running


-- =========================================================
-- Nominal wrapper
-- =========================================================
MODULE NominalR()
DEFINE
    Q_SIZE := 4;
    CONSUMED := server.server_state = received;
VAR
    client : process Client(queue);
    server : process Server(queue);
    queue  : process Queue(Q_SIZE, client.readyToProduce, server.readyToConsume);


-- =========================================================
-- Synchronization module
-- =========================================================
MODULE Sync()
VAR
    nominal  : NominalR();


-- Queue tail and head are always within bounds
SPEC AG (nominal.queue.head >= 0 & nominal.queue.head < nominal.queue.Q_SIZE)
SPEC AG (nominal.queue.tail >= 0 & nominal.queue.tail < nominal.queue.Q_SIZE)

-- The client should never write when the queue is full
-- SPEC AG !(nominal.queue.full & nominal.client.readyToProduce)

-- The server should never consume when the queue is empty
-- SPEC AG !(nominal.queue.empty & nominal.server.readyToConsume)

-- If the server is ready to consume, eventually it will receive
SPEC AG (nominal.server.readyToConsume -> AF nominal.server.server_state = received)

-- If the client is ready to produce, eventually it will send
SPEC AG (nominal.client.readyToProduce -> AF nominal.client.client_state = sent)

-- The system should never reach a state where no process can move, no deadlock
SPEC AG EF TRUE

-- Every produced message is eventually consumed
SPEC AG (nominal.client.client_state = sent -> AF nominal.server.server_state = received)

-- Under fairness, the queue shouldnâ€™t stay full or empty forever unless the other side is stopped
SPEC AG AF (!nominal.queue.full & !nominal.queue.empty)

-- Whenever nominal server consumes, eventually an extended server consumes
-- SPEC AF (nominal.CONSUMED)
SPEC AG (nominal.client.client_state = sent -> AF nominal.server.server_state = received)

-- If the tail changes, it must be because the client produced
SPEC AG (EX (nominal.queue.tail != nominal.queue.tail) -> nominal.client.readyToProduce)

-- While readyToProduce is FALSE, tail should not move 
SPEC AG (nominal.queue.readyToProduce = FALSE -> AX (nominal.queue.tail = nominal.queue.tail))

-- If produceFlag is TRUE, the tail should move
SPEC AG (nominal.queue.readyToProduce = TRUE -> AX (nominal.queue.tail != nominal.queue.tail))


-- If client wants to send and queue isn't full, eventually it sends
SPEC AG ((nominal.client.client_state = sending & !nominal.queue.full) -> AF nominal.client.client_state = sent)

-- If server wants to receive and queue isn't empty, eventually it receives
SPEC AG ((nominal.server.server_state = receiving & !nominal.queue.empty) -> AF nominal.server.server_state = received)


-- =========================================================
-- Main module
-- =========================================================
MODULE main
VAR
    sync : Sync();