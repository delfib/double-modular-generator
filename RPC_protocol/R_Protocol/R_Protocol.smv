-- R Protocol

-- Client module 
MODULE Client(ch_head_server, Q_SIZE)
VAR
    client_state : {sending, sent};     -- State of the client: sending = 0, sent = 1
    ch_tail_client : 0..3;       -- Tail pointer of the request queue
    full_channel : boolean; 

ASSIGN
    init(client_state) := sending;
    init(ch_tail_client) := 0;
    init(full_channel) := FALSE;

    next(full_channel) := ((ch_tail_client + 1) mod Q_SIZE) = ch_head_server;    
    next(client_state) :=
        case
            client_state = sending & full_channel : sending;
            client_state = sending & !full_channel : sent;
            client_state = sent & !full_channel : sending;
            client_state = sent & full_channel : sent;                 
        esac;

    -- the tail pointer is only updated once a message is sent
    next(ch_tail_client) :=
        case
            -- ch_tail_client = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            client_state = sending & !full_channel : (ch_tail_client+1) mod Q_SIZE;
            TRUE : ch_tail_client;
        esac;
FAIRNESS
    running


-- Server module
MODULE Server(ch_tail_client, Q_SIZE)
VAR
    server_state : {receiving, received};    -- State of the server: receiving = 0, received = 1
    ch_head_server : 0..3;           -- Head pointer of the request queue
    empty_channel : boolean; 

ASSIGN
    init(server_state) := receiving;
    init(ch_head_server) := 0;
    init(empty_channel) := TRUE;

    next(empty_channel) := (ch_tail_client = ch_head_server);
    next(server_state) :=
        case
            server_state = receiving & empty_channel : receiving;
            server_state = receiving & !empty_channel : received;
            server_state = received & !empty_channel : receiving;
            server_state = received & empty_channel : received;         
        esac;

    -- the head pointer is only updated once a message is read
    next(ch_head_server) :=
        case
            -- ch_head_server = receiving & !empty_channel : (ch_head_server + 1) mod Q_SIZE;
            server_state = receiving & !empty_channel : (ch_head_server + 1) mod Q_SIZE;
            TRUE : ch_head_server;
        esac;
FAIRNESS
    running


-- Top module for R Protocol
MODULE main
DEFINE
    Q_SIZE := 4;  
VAR
    client : process Client(server.ch_head_server, Q_SIZE);
    server : process Server(client.ch_tail_client, Q_SIZE);
       


-- The client should never send a message when the queue is full
-- If the client is in sent with a full queue, then in the next step it
-- must not go to sending while the queue is still full.
SPEC AG ((client.full_channel & client.client_state = sent) 
        -> AX !(client.full_channel & client.client_state = sending))

-- The server should never receive from an empty queue
-- If the server is in the received state with an empty queue, in the next step 
-- it must not go to the receiving state with an empty queue.
SPEC AG ((server.empty_channel & server.server_state = received) 
        -> AX !(server.empty_channel & server.server_state = receiving))

SPEC AG (client.ch_tail_client >= 0 & client.ch_tail_client < Q_SIZE)
SPEC AG (server.ch_head_server >= 0 & server.ch_head_server < Q_SIZE)

SPEC AG (client.client_state = sent -> AF server.server_state = received)
SPEC AG (client.client_state = sending -> AF client.client_state = sent)
SPEC AG (server.server_state = receiving -> AF server.server_state = received)
SPEC EF (EG(client.client_state = sent))






