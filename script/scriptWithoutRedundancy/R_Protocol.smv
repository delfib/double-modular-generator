-- =========================================================
-- Queue module
-- =========================================================

MODULE Queue(Q_SIZE, client_toggle, server_toggle)
VAR
    head : 0..3;
    tail : 0..3;
    last_client_toggle : boolean;  -- last toggle value we saw
    last_server_toggle : boolean;

ASSIGN
    init(head) := 0;
    init(tail) := 0;
    init(last_client_toggle) := FALSE;
    init(last_server_toggle) := FALSE;

    next(tail) := case
        (client_toggle != last_client_toggle) : (tail + 1) mod Q_SIZE;    -- produce if toggle changed (new request detected)
        TRUE : tail;
    esac;

    next(head) := case
        (server_toggle != last_server_toggle) : (head + 1) mod Q_SIZE;
        TRUE : head;
    esac;

    next(last_client_toggle) := case
        (client_toggle != last_client_toggle) : client_toggle;
        TRUE : last_client_toggle;
    esac;

    next(last_server_toggle) := case
        (server_toggle != last_server_toggle) : server_toggle;
        TRUE : last_server_toggle;
    esac;

DEFINE
    full := ((tail + 1) mod Q_SIZE = head);
    empty := (tail = head);

FAIRNESS
    running


-- =========================================================
-- Client module
-- =========================================================
MODULE Client(queue)
VAR
    client_state : {sending, sent};
    request_toggle : boolean;           

ASSIGN
    init(client_state) := sending;
    init(request_toggle) := FALSE;

    next(client_state) :=
        case
            client_state = sending & queue.full : sending;
            client_state = sending & !queue.full : sent;
            client_state = sent & !queue.full & request_toggle = queue.last_client_toggle : sending;
            client_state = sent & queue.full : sent;
            TRUE : client_state;
        esac;
 
    -- Toggle the bit each time we make a new request
    next(request_toggle) := case
        client_state = sending & !queue.full : !request_toggle;                     -- toggle!
        TRUE : request_toggle;                                                      -- keep same value otherwise
    esac;

FAIRNESS
    running


-- =========================================================
-- Server module
-- =========================================================
MODULE Server(queue)
VAR
    server_state : {receiving, received};
    request_toggle : boolean;  
ASSIGN
    init(server_state) := receiving;
    init(request_toggle) := FALSE;

    next(server_state) :=
        case
            server_state = receiving & queue.empty : receiving;
            server_state = receiving & !queue.empty : received;
            server_state = received & !queue.empty & request_toggle = queue.last_server_toggle: receiving;
            server_state = received & queue.empty : received;
            TRUE : server_state;
        esac;

    next(request_toggle) := case
        server_state = receiving & !queue.empty : !request_toggle;                   
        TRUE : request_toggle;                                                    
    esac;

FAIRNESS
    running


-- =========================================================
-- System wrapper
-- =========================================================
MODULE System()
DEFINE
    Q_SIZE := 4;
VAR
    client : process Client(queue);
    server : process Server(queue);
    queue : process Queue(Q_SIZE, client.request_toggle, server.request_toggle);


-- =========================================================
-- Main module
-- =========================================================
MODULE main
VAR
    nominal  : System();



-- SAFETY PROPERTIES
-- =================

-- Queue tail and head are always within bounds
SPEC AG (nominal.queue.head >= 0 & nominal.queue.head < nominal.queue.Q_SIZE)
SPEC AG (nominal.queue.tail >= 0 & nominal.queue.tail < nominal.queue.Q_SIZE)

-- Full and empty are mutually exclusive
SPEC AG !(nominal.queue.full & nominal.queue.empty)

-- Client doesn't produce when queue is full
SPEC AG !(nominal.queue.full & nominal.client.client_state = sending)

-- Queue full definition is correct
SPEC AG (nominal.queue.full <-> ((nominal.queue.tail + 1) mod nominal.Q_SIZE = nominal.queue.head))

-- Queue empty definition is correct
SPEC AG (nominal.queue.empty <-> (nominal.queue.tail = nominal.queue.head))


-- LIVENESS PROPERTIES
-- ===================

-- System never deadlocks - always eventually reaches a non-full, non-empty state
SPEC AG (AF (!nominal.queue.full & !nominal.queue.empty))

-- If client wants to send, it will eventually send (no starvation)
SPEC AG (nominal.client.client_state = sending -> AF nominal.client.client_state = sent)

-- If server wants to receive, it will eventually receive (no starvation)
SPEC AG (nominal.server.server_state = receiving -> AF nominal.server.server_state = received)

-- Queue never stays full forever
SPEC AG (nominal.queue.full -> AF !nominal.queue.full)

-- Queue never stays empty forever
SPEC AG (nominal.queue.empty -> AF !nominal.queue.empty)

-- Client eventually produces infinitely often
SPEC AG (AF nominal.client.client_state = sent)

-- Server eventually consumes infinitely often
SPEC AG (AF nominal.server.server_state = received)

-- FUNCTIONAL CORRECTNESS
-- ======================

-- Every produced message is eventually consumed
SPEC AG (nominal.client.client_state = sent -> AF nominal.server.server_state = received)

-- Client only transitions from sending to sent when queue is not full
SPEC AG ((nominal.client.client_state = sending & 
          AX nominal.client.client_state = sent) -> !nominal.queue.full)

-- Server only transitions from receiving to received when queue is not empty
SPEC AG ((nominal.server.server_state = receiving & 
          AX nominal.server.server_state = received) -> !nominal.queue.empty)

-- If the server enters 'received' state, the queue head must eventually advance
SPEC AG ((nominal.server.server_state = received) -> AF (nominal.server.request_toggle = nominal.queue.last_server_toggle))
         


-- TOGGLE SYNCHRONIZATION
-- ======================

-- Client toggle changes when producing
SPEC AG ((nominal.client.client_state = sending & !nominal.queue.full) -> 
         AF nominal.client.request_toggle != nominal.queue.last_client_toggle)

-- Server toggle changes when consuming
SPEC AG ((nominal.server.server_state = receiving & !nominal.queue.empty) -> 
         AF nominal.server.request_toggle != nominal.queue.last_server_toggle)

-- Queue's last_client_toggle tracks client's request_toggle after production
SPEC AG ((nominal.client.client_state = sent & 
          nominal.client.request_toggle != nominal.queue.last_client_toggle) ->
         AF nominal.queue.last_client_toggle = nominal.client.request_toggle)

-- Queue's last_server_toggle tracks server's request_toggle after consumption
SPEC AG ((nominal.server.server_state = received & 
          nominal.server.request_toggle != nominal.queue.last_server_toggle) ->
         AF nominal.queue.last_server_toggle = nominal.server.request_toggle)

-- last_client_toggle only changes when client produces
SPEC AG (nominal.queue.last_client_toggle != nominal.queue.last_client_toggle ->
         nominal.client.client_state = sent)

-- last_server_toggle only changes when server consumes
SPEC AG (nominal.queue.last_server_toggle != nominal.queue.last_server_toggle ->
         nominal.server.server_state = received)


-- FAIRNESS VERIFICATION
-- =====================

-- Both client and server make progress infinitely often
SPEC AG (AF nominal.client.client_state = sending)
SPEC AG (AF nominal.server.server_state = receiving)


-- REACHABILITY
-- ============

-- It's possible to reach a full queue
SPEC EF nominal.queue.full

-- It's possible to reach an empty queue  
SPEC EF nominal.queue.empty

-- It's possible to reach a non-empty and non-full queue
SPEC EF (!nominal.queue.empty & !nominal.queue.full)
